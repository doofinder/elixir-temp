defmodule Temp do
  @moduledoc """
  This module provides functionality for managing temporary files and directories under /tmp path (if linux).

  It offers methods to create, track, and clean up temporary resources, ensuring that these resources are properly managed during their lifecycle.
  This is particularly useful for scenarios where temporary files or directories are needed, normally used in tasks.

  [DEV NOTE] - Just call Temp.track/0 before anything else, this way files generated by Temp.open/2 can be tracked (if it's called within the same process!)

    iex> Temp.track
      {:ok, fd, _file_path} = Temp.open("cool_file")
      # do your thing ...
      IO.binwrite(fd, "Hi")
      # you can (and you should) free up resources that are not needed anymore, specially if the process continues.
      Temp.cleanup
      # No need to Temp.track again
      {:ok, _fd, _file_path} = Temp.open("ever_cooler_file")
      # do more stuff and let the process die, Temp will cleanup generated resources automatically
  """

  @doc """
  Returns `:ok` when the tracking server used to track temporary files started properly.
  """
  @pdict_key :"$__temp_tracker__"
  @type options :: nil | Path.t() | map

  @spec track :: Agent.on_start()
  def track do
    case Process.get(@pdict_key) do
      nil ->
        start_tracker()

      v ->
        {:ok, v}
    end
  end

  defp start_tracker do
    case GenServer.start_link(Temp.Tracker, nil, []) do
      {:ok, pid} ->
        Process.put(@pdict_key, pid)
        {:ok, pid}

      err ->
        err
    end
  end

  @doc """
  Same as `track/0`, but raises an exception on failure. Otherwise, returns `:ok`
  """
  @spec track! :: pid | no_return
  def track! do
    case track() do
      {:ok, pid} -> pid
      {:error, err} -> raise Temp.Error, message: err
    end
  end

  @doc """
  Return the paths currently tracked.
  """
  @spec tracked(pid()) :: Set.t()
  def tracked(tracker \\ get_tracker!()) do
    GenServer.call(tracker, :tracked)
  end

  @doc """
  Cleans up the temporary files tracked.
  """
  @spec cleanup(pid(), Keyword.t()) :: [Path.t()]
  def cleanup(tracker \\ get_tracker!(), opts \\ []) do
    GenServer.call(tracker, :cleanup, opts[:timeout] || :infinity)
  end

  @doc """
  Returns a `{:ok, path}` where `path` is a path that can be used freely in the
  system temporary directory, or `{:error, reason}` if it fails to get the
  system temporary directory.

  This path is not tracked, so any file created will need manually removing, or
  use `track_file/1` to have it removed automatically.

  ## Options

  The following options can be used to customize the generated path

    * `:prefix` - prepends the given prefix to the path

    * `:suffix` - appends the given suffix to the path,
      this is useful to generate a file with a particular extension

    * `:basedir` - places the generated file in the designated base directory
      instead of the system temporary directory
  """
  @spec path(options) :: {:ok, Path.t()} | {:error, String.t()}
  def path(options \\ nil) do
    case generate_name(options, "f") do
      {:ok, path, _} -> {:ok, path}
      err -> err
    end
  end

  @doc """
  Same as `path/1`, but raises an exception on failure. Otherwise, returns a temporary path.
  """
  @spec path!(options) :: Path.t() | no_return
  def path!(options \\ nil) do
    case path(options) do
      {:ok, path} -> path
      {:error, err} -> raise Temp.Error, message: err
    end
  end

  @doc """
  Returns `{:ok, fd, file_path}` if no callback is passed, or `{:ok, file_path}`
  if callback is passed, where `fd` is the file descriptor of a temporary file
  and `file_path` is the path of the temporary file.
  Returns `{:error, reason}` if a failure occurs.

  The resulting file is automatically tracked if tracking is enabled.

  ## Options

  See `path/1`.
  """
  @spec open(options, nil | (File.io_device() -> any)) ::
          {:ok, Path.t()} | {:ok, File.io_device(), Path.t()} | {:error, any}
  def open(options \\ nil, func \\ nil) do
    case generate_name(options, "f") do
      {:ok, path, options} ->
        options = Map.put(options, :mode, options[:mode] || [:read, :write])

        ret =
          if func do
            File.open(path, options[:mode], func)
          else
            File.open(path, options[:mode])
          end

        case ret do
          {:ok, res} ->
            if tracker = get_tracker(), do: register_path(tracker, path, res)
            if func, do: {:ok, path}, else: {:ok, res, path}

          err ->
            err
        end

      err ->
        err
    end
  end

  @doc """
  Add a file to the tracker, so that it will be removed automatically or on Temp.cleanup.
  Warning: By using this method you are in charge of closing the file decriptor if Temp.cleanup/0 is called manually.
  """
  @spec track_file(options(), pid()) ::
          {:error, :tracker_not_found} | {:ok, {Path.t(), File.io_device()}}
  def track_file(path, tracker \\ get_tracker()) do
    case is_nil(tracker) do
      true -> {:error, :tracker_not_found}
      false -> {:ok, register_path(tracker, path)}
    end
  end

  @doc """
  Same as `open/1`, but raises an exception on failure.
  """
  @spec open!(options, pid | nil) :: Path.t() | {File.io_device(), Path.t()} | no_return
  def open!(options \\ nil, func \\ nil) do
    case open(options, func) do
      {:ok, res, path} -> {res, path}
      {:ok, path} -> path
      {:error, err} -> raise Temp.Error, message: err
    end
  end

  @doc """
  Returns `{:ok, dir_path}` where `dir_path` is the path is the path of the
  created temporary directory.
  Returns `{:error, reason}` if a failure occurs.

  The directory is automatically tracked if tracking is enabled.

  ## Options

  See `path/1`.
  """
  @spec mkdir(options) :: {:ok, Path.t()} | {:error, any}
  def mkdir(options \\ %{}) do
    case generate_name(options, "d") do
      {:ok, path, _} ->
        case File.mkdir(path) do
          :ok ->
            if tracker = get_tracker(), do: register_path(tracker, path)
            {:ok, path}

          err ->
            err
        end

      err ->
        err
    end
  end

  @doc """
  Same as `mkdir/1`, but raises an exception on failure. Otherwise, returns
  a temporary directory path.
  """
  @spec mkdir!(options) :: Path.t() | no_return
  def mkdir!(options \\ %{}) do
    case mkdir(options) do
      {:ok, path} ->
        if tracker = get_tracker(), do: register_path(tracker, path)
        path

      {:error, err} ->
        raise Temp.Error, message: err
    end
  end

  @spec generate_name(options, Path.t()) ::
          {:ok, Path.t(), map | Keyword.t()} | {:error, String.t()}
  defp generate_name(options, default_prefix)

  defp generate_name(options, default_prefix) when is_list(options) do
    generate_name(Enum.into(options, %{}), default_prefix)
  end

  defp generate_name(options, default_prefix) do
    case prefix(options) do
      {:ok, path} ->
        affixes = parse_affixes(options, default_prefix)
        parts = [timestamp(), "-", :os.getpid(), "-", random_string()]

        parts =
          if affixes[:prefix] do
            [affixes[:prefix], "-"] ++ parts
          else
            parts
          end

        parts = add_suffix(parts, affixes[:suffix])
        name = Path.join(path, Enum.join(parts))
        {:ok, name, affixes}

      err ->
        err
    end
  end

  defp add_suffix(parts, suffix)
  defp add_suffix(parts, nil), do: parts
  defp add_suffix(parts, "." <> _suffix = suffix), do: parts ++ [suffix]
  defp add_suffix(parts, suffix), do: parts ++ ["-", suffix]

  defp prefix(%{basedir: dir}), do: {:ok, dir}

  defp prefix(_) do
    case System.tmp_dir() do
      nil -> {:error, "no tmp_dir readable"}
      path -> {:ok, path}
    end
  end

  defp parse_affixes(nil, default_prefix), do: %{prefix: default_prefix}
  defp parse_affixes(affixes, _) when is_bitstring(affixes), do: %{prefix: affixes, suffix: nil}

  defp parse_affixes(affixes, default_prefix) when is_map(affixes) do
    affixes
    |> Map.put(:prefix, affixes[:prefix] || default_prefix)
    |> Map.put(:suffix, affixes[:suffix] || nil)
  end

  defp parse_affixes(_, default_prefix) do
    %{prefix: default_prefix, suffix: nil}
  end

  @spec get_tracker :: any
  def get_tracker do
    Process.get(@pdict_key)
  end

  defp get_tracker! do
    case get_tracker() do
      nil ->
        raise Temp.Error, message: "temp tracker not started"

      pid ->
        pid
    end
  end

  @spec register_path(pid(), Path.t(), File.io_device() | nil) :: [{Path.t(), File.io_device()}]
  defp register_path(tracker, file_path, fd \\ nil) do
    GenServer.call(tracker, {:add, file_path, fd})
  end

  defp timestamp do
    {ms, s, _} = :os.timestamp()
    Integer.to_string(ms * 1_000_000 + s)
  end

  defp random_string do
    0x100000000 |> rand_uniform() |> Integer.to_string(36) |> String.downcase()
  end

  if :erlang.system_info(:otp_release) >= '18' do
    defp rand_uniform(num) do
      :rand.uniform(num)
    end
  else
    defp rand_uniform(num) do
      :random.uniform(num)
    end
  end
end
